---
phase: 02-error-handling
plan: 02
type: execute
---

<objective>
Add retry logic with exponential backoff for transient network failures in HTTP requests.

Purpose: Make the daemon resilient to temporary network issues, API rate limits, and brief outages
Output: Retry utility function applied to provider HTTP calls with configurable backoff
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
02-01 fixed JSON parsing vulnerabilities. Providers now handle malformed responses gracefully.

**Constraint from PROJECT.md:**
Dependencies: Minimal footprint â€” requests, PyYAML, stdlib only

**Current behavior:**
- HTTP requests fail immediately with single 5-second timeout
- No retry mechanism for transient failures
- Provider methods return False/empty list on error

**Relevant source:**
@src/external_dns/cli.py
- AdGuard: test_connection (317-325), get_records (327-334), add_record (336-345), delete_record (347-358)
- Traefik: get_routes (515-530)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry utility function with exponential backoff</name>
  <files>src/external_dns/cli.py, tests/test_utils.py</files>
  <action>
  Add a retry utility function using stdlib only (no tenacity dependency per PROJECT.md constraints).

  Add near the top of cli.py after imports, before File Watching Utilities section (~line 116):

  ```python
  # =============================================================================
  # Retry Utilities
  # =============================================================================

  def retry_with_backoff(
      func: Callable[[], T],
      *,
      max_retries: int = 3,
      base_delay: float = 1.0,
      max_delay: float = 30.0,
      exponential_base: float = 2.0,
      retryable_exceptions: tuple = (requests.exceptions.RequestException,),
  ) -> T:
      """Retry a function with exponential backoff.

      Args:
          func: Zero-argument callable to retry
          max_retries: Maximum number of retry attempts (0 = no retries)
          base_delay: Initial delay between retries in seconds
          max_delay: Maximum delay cap in seconds
          exponential_base: Base for exponential backoff calculation
          retryable_exceptions: Tuple of exception types that trigger retry

      Returns:
          Result of successful function call

      Raises:
          Last exception if all retries exhausted
      """
      last_exception: Optional[Exception] = None

      for attempt in range(max_retries + 1):
          try:
              return func()
          except retryable_exceptions as e:
              last_exception = e
              if attempt == max_retries:
                  break
              delay = min(base_delay * (exponential_base ** attempt), max_delay)
              logger.debug(f"Retry {attempt + 1}/{max_retries} after {delay:.1f}s: {e}")
              time.sleep(delay)

      raise last_exception  # type: ignore
  ```

  Also add the TypeVar import at top:
  ```python
  from typing import Any, Callable, Dict, List, Optional, Set, TypeVar
  T = TypeVar("T")
  ```

  Add tests in tests/test_utils.py:
  - `test_retry_with_backoff_succeeds_first_try` - returns result immediately when no error
  - `test_retry_with_backoff_succeeds_after_retry` - retries and succeeds on later attempt
  - `test_retry_with_backoff_exhausts_retries` - raises last exception after max retries
  - `test_retry_with_backoff_respects_max_delay` - delay capped at max_delay
  - `test_retry_with_backoff_only_retries_specified_exceptions` - non-retryable exceptions propagate immediately
  </action>
  <verify>
  - `make lint` passes
  - `make test` passes all tests including new ones
  - `pytest tests/test_utils.py -v -k retry` shows new tests passing
  </verify>
  <done>
  - `retry_with_backoff()` function added to cli.py
  - Function supports configurable retries, delays, and exception types
  - At least 5 new tests for retry behavior
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply retry logic to provider HTTP calls</name>
  <files>src/external_dns/cli.py, tests/test_adguard_provider.py, tests/test_traefik_provider.py</files>
  <action>
  Wrap HTTP requests in providers with retry_with_backoff for transient failures.

  **AdGuard provider changes:**

  1. In `test_connection()` - retry connection test:
  ```python
  def test_connection(self) -> bool:
      def _do_request():
          response = self._session.get(f"{self._url}/control/status", timeout=5)
          response.raise_for_status()
          return True

      try:
          result = retry_with_backoff(_do_request, max_retries=2, base_delay=1.0)
          logger.info(f"{self.name} connection successful")
          return result
      except requests.exceptions.RequestException as e:
          logger.error(f"Failed to connect to {self.name}: {e}")
          return False
  ```

  2. In `get_records()` - retry record fetch (already returns [] on error, so use retry):
  ```python
  def get_records(self) -> List[DNSRecord]:
      def _do_request():
          response = self._session.get(f"{self._url}/control/rewrite/list", timeout=5)
          response.raise_for_status()
          return response.json()

      try:
          data = retry_with_backoff(_do_request, max_retries=2, base_delay=1.0)
      except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
          logger.error(f"Failed to get records from {self.name}: {e}")
          return []
      # ... rest of parsing logic
  ```

  3. In `add_record()` and `delete_record()` - retry mutations:
  ```python
  def add_record(self, domain: str, answer: str) -> bool:
      def _do_request():
          data = {"domain": domain, "answer": answer}
          response = self._session.post(f"{self._url}/control/rewrite/add", json=data, timeout=5)
          response.raise_for_status()
          return True

      try:
          retry_with_backoff(_do_request, max_retries=2, base_delay=1.0)
          logger.info(f"Added DNS record: {domain} -> {answer}")
          return True
      except requests.exceptions.RequestException as e:
          logger.error(f"Failed to add record for {domain}: {e}")
          return False
  ```

  **Traefik provider changes:**

  In `get_routes()` - retry route fetch:
  ```python
  def get_routes(self, instance: ProxyInstance) -> List[ProxyRoute]:
      session = requests.Session()
      if instance.username and instance.password:
          session.auth = HTTPBasicAuth(instance.username, instance.password)

      base = instance.url.rstrip("/")

      def _do_request():
          response = session.get(
              f"{base}/api/http/routers",
              timeout=self._timeout,
              verify=instance.verify_tls,
          )
          response.raise_for_status()
          return response.json()

      try:
          routers = retry_with_backoff(_do_request, max_retries=2, base_delay=1.0)
      except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
          logger.error(f"Failed to get routes from {instance.name}: {e}")
          raise  # Re-raise so sync_once() can handle instance failure
      # ... rest of processing
  ```

  **Add tests:**
  In test_adguard_provider.py:
  - `test_test_connection_retries_on_transient_failure` - mock first request fail, second succeed
  - `test_get_records_retries_on_transient_failure`
  - `test_add_record_retries_on_transient_failure`

  In test_traefik_provider.py:
  - `test_get_routes_retries_on_transient_failure`
  </action>
  <verify>
  - `make lint` passes
  - `make test` passes all tests including new ones
  - Log output shows retry attempts in debug mode
  </verify>
  <done>
  - AdGuard provider: test_connection, get_records, add_record, delete_record all use retry
  - Traefik provider: get_routes uses retry
  - At least 4 new tests verify retry behavior
  - Retry params: max_retries=2, base_delay=1.0 (reasonable defaults)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make lint` passes (ruff check)
- [ ] `make test` passes all tests
- [ ] Retry utility function is well-tested
- [ ] Providers retry on transient failures
- [ ] No unnecessary retries on permanent failures (4xx errors)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- retry_with_backoff utility tested and working
- All provider HTTP calls have retry logic
- At least 9 new tests (5 utility + 4 provider)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-02-SUMMARY.md`
</output>
