---
phase: 02-error-handling
plan: 01
type: execute
---

<objective>
Fix JSON parsing vulnerabilities in provider implementations to handle malformed responses gracefully.

Purpose: Prevent sync cycle crashes when AdGuard or Traefik APIs return unexpected/malformed data
Output: Robust JSON parsing in both providers with proper error handling and tests
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

**Prior phase context:**
Phase 1 completed with 99 unit tests. Mock providers exist for isolated testing.

**Known bugs from CONCERNS.md:**
1. Unsafe JSON key access in AdGuard `get_records()` (line 331): `r["domain"]`, `r["answer"]` without validation
2. Unhandled JSONDecodeError in Traefik `get_routes()` (lines 528-530): Only `RequestException` caught

**Relevant source:**
@src/external_dns/cli.py (lines 303-359 AdGuard provider, 515-567 Traefik get_routes)

**Testing patterns established:**
@tests/test_adguard_provider.py - HTTP mocking with responses library
@tests/test_traefik_provider.py - HTTP mocking for route discovery
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix AdGuard provider JSON parsing</name>
  <files>src/external_dns/cli.py, tests/test_adguard_provider.py</files>
  <action>
  In `AdGuardDNSProvider.get_records()` (around line 327-334):

  1. Add try/except around JSON parsing and record iteration
  2. Use `.get()` with validation instead of direct key access: `r["domain"]` -> validate `r.get("domain")` exists and is string
  3. Skip malformed records with warning log instead of crashing
  4. Add `json.JSONDecodeError` to the except clause alongside `RequestException`

  Changes needed:
  ```python
  def get_records(self) -> List[DNSRecord]:
      try:
          response = self._session.get(f"{self._url}/control/rewrite/list", timeout=5)
          response.raise_for_status()
          data = response.json()
      except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
          logger.error(f"Failed to get records from {self.name}: {e}")
          return []

      records = []
      for r in data:
          domain = r.get("domain") if isinstance(r, dict) else None
          answer = r.get("answer") if isinstance(r, dict) else None
          if not isinstance(domain, str) or not isinstance(answer, str):
              logger.warning(f"Skipping malformed record: {r}")
              continue
          records.append(DNSRecord(domain=domain, answer=answer))
      return records
  ```

  Add tests in test_adguard_provider.py:
  - `test_get_records_handles_malformed_json_response` - returns empty list on invalid JSON
  - `test_get_records_skips_malformed_records` - continues parsing valid records when some are malformed
  - `test_get_records_handles_missing_fields` - skips records missing domain/answer
  </action>
  <verify>
  - `make lint` passes
  - `make test` passes all tests including new ones
  - `pytest tests/test_adguard_provider.py -v` shows new tests passing
  </verify>
  <done>
  - AdGuard `get_records()` catches JSONDecodeError
  - Malformed records logged and skipped, not crashed
  - At least 3 new tests for error scenarios
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Traefik provider JSON parsing</name>
  <files>src/external_dns/cli.py, tests/test_traefik_provider.py</files>
  <action>
  In `TraefikProxyProvider.get_routes()` (around line 515-567):

  1. Add `json.JSONDecodeError` to the except clause (currently only catches `RequestException`)
  2. Add validation for router dict structure before accessing fields
  3. Handle case where `response.json()` returns non-list data

  Changes needed to the try/except block:
  ```python
  try:
      response = session.get(
          f"{base}/api/http/routers",
          timeout=self._timeout,
          verify=instance.verify_tls,
      )
      response.raise_for_status()
      routers = response.json()
  except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
      logger.error(f"Failed to get routes from {instance.name}: {e}")
      raise  # Re-raise so sync_once() can handle instance failure

  # Validate routers is a list
  if not isinstance(routers, list):
      logger.error(f"Unexpected response format from {instance.name}: expected list, got {type(routers).__name__}")
      return []
  ```

  Also add validation in the router loop:
  ```python
  for router in routers:
      if not isinstance(router, dict):
          logger.debug(f"Skipping non-dict router entry: {router}")
          continue
      router_name = router.get("name") or ""
      # ... rest of processing
  ```

  Add tests in test_traefik_provider.py:
  - `test_get_routes_handles_invalid_json` - raises RequestException on malformed JSON
  - `test_get_routes_handles_non_list_response` - returns empty list if response is not a list
  - `test_get_routes_skips_non_dict_routers` - continues processing when some router entries are invalid
  </action>
  <verify>
  - `make lint` passes
  - `make test` passes all tests including new ones
  - `pytest tests/test_traefik_provider.py -v` shows new tests passing
  </verify>
  <done>
  - Traefik `get_routes()` catches JSONDecodeError
  - Non-list responses handled gracefully
  - Invalid router entries logged and skipped
  - At least 3 new tests for error scenarios
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make lint` passes (ruff check)
- [ ] `make test` passes all tests
- [ ] Both providers handle malformed JSON without crashing
- [ ] Both providers have tests for JSON error scenarios
- [ ] Log messages are clear and helpful for debugging
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No uncaught JSONDecodeError in either provider
- Malformed data logged and skipped, sync continues
- At least 6 new tests (3 per provider)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-01-SUMMARY.md`
</output>
